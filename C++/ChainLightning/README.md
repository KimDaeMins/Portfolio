# ChainLightning

## 애니메이션 상으로는 조절되지 않은 뼈의 추가적인 회전 및 이동

<img width="824" alt="image" src="https://github.com/KimDaeMins/Portfolio/assets/68540137/9e7c398f-82ba-463d-956e-798b7325a5b5">

## 핵심 코드

![image](https://github.com/KimDaeMins/Portfolio/assets/68540137/a5d05ac8-8fb8-49b8-9f2d-6483bdc4cb5c)

스킬 최초 충돌 객체를 Key값으로 하고 그 객체 기준 가장 가까운 객체를 Second값으로 하는 Pair객체 생성 후 map에 넣는 방식으로 Monster를 연결합니다.

![image](https://github.com/KimDaeMins/Portfolio/assets/68540137/5e21549d-bd40-4dda-a804-d3f3df0a0922)

Value가 된 객체들을 Key값으로 둔 후 순회하는 방식으로, 연결되는 객체가 없어질때까지 반복순회하며 계층구조를 만듭니다.

<img width="522" alt="image" src="https://github.com/KimDaeMins/Portfolio/assets/68540137/6bbf348f-f624-4260-ba1a-9b3431b6a107">

map계층구조를 순회하며 탐색합니다.

### 상세 설명

#### 1. 체인 라이트닝을 순회할 리스트를 만듭니다.

    1-1. 오브젝트 매니저의 오브젝트리스트를 전부 들고와서 한 리스트에 넣습니다.

    1-2. 최대 체인수와 길이를 조절합니다.

    1-3. 몬스터간의 거리를 저장할 Distance배열도 만들어둡니다.

    1-4. 최초로 맞은 몬스터는 몬스터리스트에서 제외합니다 ( 이 몬스터를 기준으로 순회하여 집어넣을 예정입니다 )

    구현위치 IceDaggerLightnign.cpp Line[119-141]

#### 2. 1-3몬스터 기준 가장 가까운 몬스터를 찾아서 저장합니다. 

    2-1. 몬스터 리스트를 순회하여 Distance를 구하고 현재 저장된 몬스터중 가장 먼 녀석과 비교합니다.

    2-2. 저장된 Distance보다 짧다면 NearObject에 저장합니다.

    2-3. 넣은 몬스터들은 몬스터리스트에서 지웁니다. (최초 몬스터 기준 순회기때문에 가장 가까운 적을 단순탐색한 느낌입니다)

    2-4. 체인라이트닝의 계층구조를 표현할 맵에 첫 타겟과 가까운 몬스터Vector를 넣습니다.
    
    구현위치 IceDaggerLightnign.cpp Line[144-191]

#### 3. 2-4에 저장된 가까운 몬스터 Vector를 순회하여 정렬 후 담는 방식을 수행합니다.

    3-1. 몬스터 리스트를 순회하여 기준몬스터와 가까운 몬스터들을 넣습니다.

    3-2. vector를 거리순에 따라 정렬합니다 (Priority_Queue를 사용하면 좀 더 깔끔했을 것 같습니다.)

    3-3. 가장 가까운 오브젝트를 저장합니다.

    3-4. 가장 가까운 오브젝트가 이미 저장된 오브젝트이면 변경된 오브젝트 기준 저장된 오브젝트들과 전부 비교하여 거리계산 후 교체하는 작업을 진행합니다. 

    구현위치 IceDaggerLightnign.cpp Line[345-494]

  #### 4. 마지막으로 저장된 map을 순회하여 연결된 번개를 꽃습니다.

    4-1. 처음 맞은 적을 저장했기떄문에 처음맞은적을 Key로 Value를 찾고 Value에 들어있는 3몬스터를 또 Key값으로 Value를 찾는 방식을 계속 반복합니다.

    구현위치 IceDaggerLightnign.cpp Line[234-266]

## 개선사항

이 코드를 구현했을 때는 BFS알고리즘에 대해 잘 모르는 상태로 만들었었습니다.

BFS알고리즘을 이용해서 각 몬스터들과의 관계를 전부 정리한 후(그래프화 시켜서) 뽑아쓰는게 훨씬 좋았을 것 같습니다.

지금에서 코드를 짠다면 <거리,몬스터> pair객체를 만들고, PriorityQueue에 저장 후 정렬방식을 거리순으로 조절한 후  앞에서부터 꺼내어서 쓰는 방식이나

행렬(2차원벡터)을 만들어서 각각 거리를 저장한 후 순회하는 방식을 이용할 것 같습니다.
 
첫번째 방식은 순회가 편하다는 장점이 있고, 두번째 방식은 데이터 정리(더 가까운 오브젝트가 있다면 바꾸거나, 상위계층에서 저장된 객체라면 제외)를 더 편하게 할 수 있다는 장점이 있습니다.

